
# Information about all exercises in the file 3-varform.do.txt.
# The information can be loaded into a Python list of dicts by
#
# f = open('.3-varform.exerinfo', 'r')
# exer = eval(f.read())
#
[{'answer': '',
  'chapter_exercise': 1,
  'chapter_no': 1,
  'chapter_title': u'Variational formulations with global basis functions',
  'chapter_type': 'Chapter',
  'closing_remarks': '',
  'file': [u'uxx_f_sympy_class'],
  'heading': u'=====',
  'hints': [],
  'keywords': None,
  'label': u'fem:deq:exer:BVP1D:class',
  'no': 1,
  'solution': u'This is an exercise in software engineering.\nThe model-specific information is related to the boundary\nconditions only. We can then let the super class take care of the\ndifferential equation and the solution process, while subclasses\nprovide a method `get_bc` to\nreturn the symbolic expressions for the boundary equations.\n\nThe super class may be coded as\nshown below.\n\n!bc pycod\nimport sympy as sym\nx, L, C, D, c_0, c_1, = sym.symbols(\'x L C D c_0 c_1\')\n\nclass TwoPtBoundaryValueProblem(object):\n    """\n    Solve -(a*u\')\' = f(x) with boundary conditions\n    specified in subclasses (method get_bc).\n    a and f must be sympy expressions of x.\n    """\n    def __init__(self, f, a=1, L=L, C=C, D=D):\n        """Default values for L, C, D are symbols."""\n        self.f = f\n        self.a = a\n        self.L = L\n        self.C = C\n        self.D = D\n\n        # Integrate twice\n        u_x = - sym.integrate(f, (x, 0, x)) + c_0\n        u = sym.integrate(u_x/a, (x, 0, x)) + c_1\n        # Set up 2 equations from the 2 boundary conditions and solve\n        # with respect to the integration constants c_0, c_1\n        eq = self.get_bc(u)\n        eq = [sym.simplify(eq_) for eq_ in eq]\n        print(\'BC eq:\', eq)\n        self.u = self.apply_bc(eq, u)\n\n    def apply_bc(self, eq, u):\n        # Solve BC eqs respect to the integration constants\n        r = sym.solve(eq, [c_0, c_1])\n        # Substitute the integration constants in the solution\n        u = u.subs(c_0, r[c_0]).subs(c_1, r[c_1])\n        u = sym.simplify(sym.expand(u))\n        return u\n\n    def get_solution(self, latex=False):\n        return sym.latex(self.u, mode=\'plain\') if latex else self.u\n\n    def get_residuals(self):\n        """Return the residuals in the equation and BCs."""\n        R_eq = sym.diff(sym.diff(self.u, x)*self.a, x) + self.f\n        R_0, R_L = self.get_bc(self.u)\n        residuals = [sym.simplify(R) for R in (R_eq, R_0, R_L)]\n        return residuals\n\n    def get_bc(self, u):\n        raise NotImplementedError(\n            \'class %s has not implemented get_bc\' %\n            self.__class__.__name__)\n\n!ec\nThe various subclasses deal with the boundary conditions of the\nvarious model problems:\n\n!bc pycod\nclass Model1(TwoPtBoundaryValueProblem):\n    """u(0)=0, u(L)=D."""\n    def get_bc(self, u):\n        return [u.subs(x, 0)-0,               # x=0 condition\n                u.subs(x, self.L) - self.D]   # x=L condition\n\nclass Model2(TwoPtBoundaryValueProblem):\n    """u\'(0)=C, u(L)=D."""\n    def get_bc(self, u):\n        return [sym.diff(u,x).subs(x, 0) - self.C, # x=0 cond.\n                u.subs(x, self.L) - self.D]        # x=L cond.\n\nclass Model3(TwoPtBoundaryValueProblem):\n    """u(0)=C, u(L)=D."""\n    def get_bc(self, u):\n        return [u.subs(x, 0) - self.C,\n                u.subs(x, self.L) - self.D]\n\n!ec\n\nA suitable test function gets quite compact:\n\n!bc pycod\ndef test_TwoPtBoundaryValueProblem():\n    f = 2\n    model = Model1(f)\n    print(\'Model 1, u:\', model.get_solution())\n    for R in model.get_residuals():\n        assert R == 0\n\n    f = x\n    model = Model2(f)\n    print(\'Model 2, u:\', model.get_solution())\n    for R in model.get_residuals():\n        assert R == 0\n\n    f = 0\n    a = 1 + x**2\n    model = Model3(f, a=a)\n    print(\'Model 3, u:\', model.get_solution())\n    for R in model.get_residuals():\n        assert R == 0\n\n!ec\n\nThe fourth model is just about defining the boundary conditions as equations:\n\n!bc pycod\nclass Model4(TwoPtBoundaryValueProblem):\n    """u(0)=0, -u\'(L)=C*(u-D)."""\n    def get_bc(self, u):\n        return [u.subs(x, 0) - 0,\n                -sym.diff(u, x).subs(x, self.L) -\n                self.C*(u.subs(x, self.L) - self.D)]\n\n!ec\nA demo function goes like\n\n!bc pycod\ndef demo_Model4():\n    f = 0\n    model = Model4(f, a=sym.sqrt(1+x))\n    print(\'Model 4, u:\', model.get_solution())\n\n!ec\nThe printout shows that the solution is\n\n!bt\n\\[ u(x) = \\frac{2CD\\sqrt{1+L}(\\sqrt{1+x}-1}{2C\\sqrt{1+L} + 2C+1}{\\thinspace .}\\]\n\n!et',
  'solution_file': None,
  'subex': [],
  'text': u"Section ref{fem:deq:1D:models:simple} lists three functions for\ncomputing the analytical solution of some simple model problems. There\nis quite some repetitive code, suggesting that the functions can\nbenefit from being refactored into a class hierarchy, where the super\nclass solves $-(a(x)u'(x))'=f(x)$ and where subclasses define the\nequations for the boundary conditions in a model. Make a method for\nreturning the residual in the differential equation and the boundary\nconditions when the solution is inserted in these equations. Create a\ntest function that verifies that all three residuals vanish for each\nof the model problems in Section ref{fem:deq:1D:models:simple}.  Also\nmake a method that returns the solution either as `sympy` expression\nor as a string in LaTeX format.  Add a fourth subclass for the problem\n$-(au')'=f$ with a Robin boundary condition:\n\n!bt\n\\[ u(0)=0,\\quad -u'(L) = C(u - D){\\thinspace .}\\]\n\n!et\nDemonstrate the use of this subclass for the case $f=0$ and $a=\\sqrt{1+x}$.",
  'title': u'Refactor functions into a more general class',
  'type': u'Exercise',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': 2,
  'chapter_no': 1,
  'chapter_title': u'Variational formulations with global basis functions',
  'chapter_type': 'Chapter',
  'closing_remarks': '',
  'file': [u'cable_sin'],
  'heading': u'=====',
  'hints': [],
  'keywords': None,
  'label': u'fem:deq:exer:tension:cable',
  'no': 2,
  'solution': '',
  'solution_file': None,
  'subex': [{'answer': '',
             'file': None,
             'hints': [],
             'solution': u'Exercise ref{fem:deq:exer:BVP1D:class} or\nSection ref{fem:deq:1D:models:simple} features tools for finding\nthe analytical solution of this differential equation.\nThe present\nmodel problem is close to model 2\nin Section ref{fem:deq:1D:models:simple}. We can modify the `model2`\nfunction:\n\n!bc pycod\ndef model():\n    """Solve u\'\' = -1, u(0)=0, u\'(1)=0."""\n    import sympy as sym\n    x, c_0, c_1, = sym.symbols(\'x c_0 c_1\')\n    u_x = sym.integrate(1, (x, 0, x)) + c_0\n    u = sym.integrate(u_x, (x, 0, x)) + c_1\n    r = sym.solve([u.subs(x,0) - 0,\n                   sym.diff(u,x).subs(x, 1) - 0],\n                  [c_0, c_1])\n    u = u.subs(c_0, r[c_0]).subs(c_1, r[c_1])\n    u = sym.simplify(sym.expand(u))\n    return u\n\n!ec\nThe solution becomes\n\n!bt\n\\[ u(x) = \\frac{1}{2}x(x-2){\\thinspace .}\\]\n\n!et\nPlotting $u(x)$ shows that $|u|\\in [0,\\frac{1}{2}]$ which is compatible with\nthe aim of the scaling, i.e., to have $u$ of size *about* unity (at least\nnot very small or very large).',
             'text': u'Find the exact solution for the deflection $u$.'},
            {'answer': '',
             'file': None,
             'hints': [u'In this case, where the basis functions and their derivatives are\northogonal, it is easiest to set up the calculations by hand and\nuse `sympy` to help out with the integrals.'],
             'solution': u'With $u=\\sum_{j=0}^Nc_j{\\psi}_j(x)$ the residual becomes\n\n!bt\n\\[ R = 1 - u\'\' = 1 +\\sum_{j=0}^Nc_j{\\psi}_j\'\'(x) =\n1 + \\sum_{j=0}^Nc_j(2j+1)^2\\frac{\\pi^2}{4}\\sin((2j+1)\\frac{\\pi x}{2}){\\thinspace .}\\]\n\n!et\n\n\n__Least squares method.__\nThe minimization of $\\int_0^1R^2dx$ leads to the equations\n\n!bt\n\\[ (R,\\frac{\\partial R}{\\partial c_i})=0,\\quad i=0,\\ldots,N{\\thinspace .}\\]\n\n!et\nWe find that\n\n!bt\n\\[ \\frac{\\partial R}{\\partial c_i} =\n(2i+1)^2\\frac{\\pi^2}{4}\\sin((2i+1)\\frac{\\pi x}{2}),\\]\n\n!et\nso the governing equations become\n\n!bt\n\\[ (1+\\sum_{j=0}^Nc_j(2j+1)^2\\frac{\\pi^2}{4}\\sin((2j+1)\\frac{\\pi x}{2}),\n(2i+1)^2\\frac{\\pi^2}{4}\\sin((2i+1)\\frac{\\pi x}{2}) = 0{\\thinspace .}\\]\n\n!et\nBy linearity of the inner product (or integral) this expression can\nbe reordered to\n\n!bt\n\\begin{align*}\n\\sum_{j=0}^Nc_j((2j+1)^2\\frac{\\pi^2}{4}\\sin((2j+1)\\frac{\\pi x}{2}), &\n(2i+1)^2\\frac{\\pi^2}{4}\\sin((2i+1)\\frac{\\pi x}{2}) = \\\\ \n& -(1, (2i+1)^2\\frac{\\pi^2}{4}\\sin((2i+1)\\frac{\\pi x}{2})),\n\\end{align*}\n\n!et\nwhich is nothing but a linear system\n\n!bt\n\\[ \\sum_{j=0}^N A_{i,j}c_j = b_i,\\quad i=0,\\ldots,N,\\]\n\n!et\nwith\n\n!bt\n\\begin{align*}\nA_{i,j} &= (2j+1)^4\\frac{\\pi^4}{16}\\int_0^1\n\\sin((2j+1)\\frac{\\pi x}{2})\\sin((2i+1)\\frac{\\pi x}{2})dx,\\\\ \nb_i &= -(2i+1)^2\\frac{\\pi^2}{4}\\int_0^1 \\sin((2i+1)\\frac{\\pi x}{2})dx\n\\end{align*}\n\n!et\nOrthogonality of the sine functions $\\sin (k\\pi x/2)$ on $[0,1]$\nfor integer $k$ implies that\n$A_{i,j}=0$ for $i\\neq j$, and $A_{i,i}$ can be\ncomputed by `sympy`:\n\n!bc pyshell\n>>> from sympy import *\n>>> i = symbols(\'i\', integer=True)\n>>> x = symbols(\'x\', real=True)\n>>> integrate(sin(i*pi*x/2)**2, (x, 0, 1))\n1/2\n\n!ec\nTherefore,\n\n!bt\n\\[ A_{i,j} = \\left\\lbrace\\begin{array}{ll}\n0,& i\\neq j\\\\ \n\\frac{1}{2} (2i+1)^4\\frac{\\pi^4}{16}, & i = j\n\\end{array}\\right.\n\\]\n\n!et\nThe right-hand side can also be computed by `sympy`:\n\n!bc pyshell\n>>> integrate(sin((2*i+1)*pi*x/2), (x, 0, 1))\n2/(pi*(2*i+1))\n\n!ec\nOne should always be skeptical to symbolic software and integration of\nperiodic functions like the sine and cosine since the answers can be\ntoo simplistic (see subexercise d!).\nA general test is to perform numerical integration with\nlots of sampling points to (partially) verify the symbolic formula.\nHere is an application of the midpoint rule:\n\n!bc pycod\ndef midpoint_rule(f, M=100000):\n    """Integrate f(x) over [0,1] using M intervals."""\n    from numpy import sum, linspace\n    dx = 1.0/M                       # interval length\n    x = linspace(dx/2, 1-dx/2, M)    # integration points\n    return dx*sum(f(x))\n\ndef check_integral_b():\n    from numpy import pi, sin\n    for i in range(12):\n        exact = 2/(pi*(2*i+1))\n        numerical = midpoint_rule(\n            f=lambda x: sin((2*i+1)*pi*x/2))\n        print(i, abs(exact - numerical))\n\n!ec\nThe output shows that the difference between numerical and exact\nintegration is about $10^{-11}$, which is ``small\'\' (and gets smaller\nby just increasing `M`). This result brings evidence that the\n`sympy` answer is correct.\nAlternatively, in this simple case, we can easily calculate the anti-derivative.\nIt goes like\n\n!bt\n\\[ -\\frac{2}{\\pi(2i+1)}\\cos((2k+1)\\frac{\\pi x}{2}),\\]\n\n!et\nand for $x=1$ we get\n$\\cos\\frac{\\pi}{2}$, $\\cos 3\\frac{\\pi}{2}$, $\\cos 5\\frac{\\pi}{2}$,\nand so on, which all evaluates to zero, and since the cosine is 1 for $x=0$,\nthe formula found by `sympy` is correct.\n\nWe then get\n\n!bt\n\\[ b_i = -(2i+1)^2\\frac{\\pi^2}{4}\\frac{2}{\\pi(2i+1)} = -\\frac{1}{2} (2i+1)\\pi,\\]\n\n!et\nand consequently,\n\n!bt\n\\[ c_i = \\frac{b_i}{A_{i,i}} = -\\frac{\\frac{1}{2} (2i+1)\\pi}{\\frac{1}{2} (2i+1)^4}\\frac{\\pi^4}{16} = -\\frac{16}{\\pi^3(2i+1)^3}{\\thinspace .}\\]\n\n!et\n\n__Galerkin\'s method.__\nThe Galerkin method applied to this problem\nstarts with\n\n!bt\n\\[ (u\'\',v) = (1,v)\\quad \\forall v\\in V,\\]\n\n!et\nand the requirement that $v(0)=0$ since $u(0)=0$.\nIntegration by parts and using $u\'(1)=0$ and $v(0)=0$ makes the boundary\nterm vanish, and the variational form becomes\n\n!bt\n\\[ (u\',v\') = -(1,v) \\quad \\forall v\\in V{\\thinspace .}\\]\n\n!et\nInserting $u=\\sum_{j=0}^Nc_j{\\psi}_j(x)$ and $v={\\psi}_i$ leads to\n\n!bt\n\\[ \\sum_{j=0}^N ({\\psi}_j\', {\\psi}_i\')c_j = (1,{\\psi}_i),\\quad i=0,\\ldots,N{\\thinspace .}\n\\]\n\n!et\nWith ${\\psi}_i=\\sin((2i+1)\\frac{\\pi x}{2})$ the matrix entries become\n\n!bt\n\\[ A_{i,j} =  (2i+1)(2j+1)\\frac{\\pi^2}{4}\\int_0^1 \\cos((2i+1)\\frac{\\pi x}{2})\n\\cos((2j+1)\\frac{\\pi x}{2})dx{\\thinspace .}\\]\n\n!et\nOrthogonality of the cosine functions implies $A_{i,j}=0$ for\n$i\\neq j$, and $A_{i,i}$ is computed by integrating the square\nof the cosine function,\n\n!bc pyshell\n>>> integrate(cos((k+1)*pi*x/2)**2, (x, 0, 1))\n1/2\n\n!ec\nNow,\n\n!bt\n\\[ A_{i,i} = (2i+1)^2\\frac{\\pi^2}{4}\\frac{1}{2} = \\frac{1}{8}(2i+1)^2 \\pi^2{\\thinspace .}\\]\n\n!et\nThe right-hand side has almost the same integral as in the\nleast squares case,\n\n!bt\n\\[ b_i = -\\int_0^1 \\sin((2i+1)\\frac{\\pi x}{2})dx = -\\frac{2}{\\pi (2i+1)}{\\thinspace .}\\]\n\n!et\nConsequently,\n\n!bt\n\\[ c_i = \\frac{b_i}{A_{i,i}} = -\\frac{16}{\\pi^3(2i+1)^3},\\]\n\n!et\nwhich is the same result as we obtained in the least squares method.\n\n\n__Decay of coefficients.__\nThe coefficients decay,\n\n!bt\n\\[ \\frac{c_i}{c_{i+1}} = \\left(\\frac{2i+3}{2i+1}\\right)^3 > 0{\\thinspace .}\\]\n\n!et\nThe decay is most pronounced for the first terms:\n\n!bc pyshell\n>>> for i in range(10):\n...   print(float(2*i+3)/(2*i+1))**3\n...\n27.0\n4.62962962963\n2.744\n2.12536443149\n1.82578875171\n1.65063861758\n1.53618570778\n1.4557037037\n1.39609200081\n1.35019682169\n\n!ec\n\n__Error in one-term solution.__\nKeeping just one term ($N=0$) means that\n\n!bt\n\\[ u(x) = -\\frac{16}{\\pi^3}\\sin(\\frac{\\pi x}{2}){\\thinspace .}\\]\n\n!et\nThe maximum deflection at $x=1$ becomes $-16\\pi^{-3}=-0.5160$, to be compared\nwith the exact value $-\\frac{1}{2}$. The error is 3.2 percent.',
             'text': u"A possible function space is spanned by ${\\psi}_i=\\sin ((2i+1)\\pi x/2)$,\n$i=0,\\ldots,N$. These functions\nfulfill the necessary condition ${\\psi}_i(0)=0$,\nbut they also fulfill ${\\psi}_i'(1)=0$ such that both boundary\nconditions are fulfilled by the expansion $u=\\sum_jc_j{\\varphi}_j$.\n\nUse a Galerkin and a least squares method to find the coefficients\n$c_j$ in $u(x)=\\sum_j c_j{\\psi}_j$. Find how fast the coefficients\ndecrease in magnitude by looking at $c_j/c_{j-1}$.\nFind the error in the maximum deflection at $x=1$ when only one\nbasis function is used ($N=0$)."},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': u"First we need a function to compute the approximate $u$ in this case:\n\n!bc pycod\ndef sine_sum(x, N):\n    s = 0\n    from numpy import pi, sin, zeros\n    u = [] # u[k] is the sum i=0,...,k\n    k = 0\n    for i in range(N+1):\n        s += - 16.0/((2*i+1)**3*pi**3)*sin((2*i+1)*pi*x/2)\n        u.append(s.copy())  # important with copy!\n    return u\n\n!ec\nNote the need to append `s.copy()`: doing just `u.append(s)` will\nmake, e.g., `u[0]` a reference to `s`, which at the end of the\nloop is an array corresponding to the maximum $i$ value.\n\nWe also need a function that can create an appropriate plot:\n\n!bc pycod\ndef plot_sine_sum():\n    from numpy import linspace\n    x = linspace(0, 1, 501)  # coordinates for plot\n    u = sine_sum(x, N=10)\n    u_e = 0.5*x*(x-2)\n    N_values = 0, 1, 10\n    for k in N_values:\n        plt.plot(x, u[k])\n    plt.plot(x, u_e)\n    plt.legend(['N=%d' % k for k in N_values] + ['exact'],\n               loc='upper right')\n    plt.xlabel('$x$');  plt.ylabel('$u$')\n    plt.savefig('tmpc.png'); plt.savefig('tmpc.pdf')\n\n!ec\n\nThe plot shows that the solution for $N=0$ has a slight deviation from the\nexact curve, but even $N=1$ catches up visually with the exact solution (!).\n\nFIGURE: [fig/cable_sin_c, width=500 frac=0.8]",
             'text': u'Visualize the solutions in b) for $N=0,1,20$.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': u'According to the calculations in b), the Galerkin method, with\n${\\psi}_i = \\sin((i+1)\\frac{\\pi x}{2})$, leads to the almost the\nsame\nmatrix entries on the diagonal:\n\n!bt\n\\begin{align*}\nA_{i,i} &= (i+1)(j+1)\\frac{\\pi^2}{4}\\int_0^1 \\cos((i+1)\\frac{\\pi x}{2})\n\\cos((j+1)\\frac{\\pi x}{2})dx\\\\ \n&= (i+1)^2\\frac{\\pi^2}{4}\\frac{1}{2} = \\frac{1}{8}(i+1)^2 \\pi^2{\\thinspace .}\n\\end{align*}\n\n!et\nThe right-hand side becomes (as before)\n\n!bt\n\\[ b_i = -\\int_0^1 \\sin((i+1)\\frac{\\pi x}{2})dx = -\\frac{2}{\\pi (i+1)}{\\thinspace .}\\]\n\n!et\nWe may use `sympy` to integrate,\n\n!bc pyshell\n>>> integrate(sin((i+1)*pi*x/2), (x, 0, 1))\n2/(pi*(i+1))\n\n!ec\nAs noted in b), let us be a bit skeptical to this answer and check it.\nA quick check with numerical integration,\n\n!bc pycod\ndef check_integral_d_sympy_answer():\n    from numpy import pi, sin\n    for i in range(12):\n        exact = 2/(pi*(i+1))\n        numerical = midpoint_rule(\n            f=lambda x: sin((i+1)*pi*x/2))\n        print(i, abs(exact - numerical))\n\n!ec\ngives the output\n\n!bc\n0 6.54487575247e-12\n1 0.31830988621\n2 1.96350713466e-11\n3 0.159154943092\n4 3.27249061183e-11\n5 0.106103295473\n6 4.58150045679e-11\n7 0.0795774715459\n8 5.89047144395e-11\n9 0.0636619773677\n10 7.19949447281e-11\n11 0.0530516476973\n\n!ec \nIt is clear that for $i$ odd, there are significant differences between\nthe `sympy` answer and the midpoint rule with high resolution!\n\nWe therefore need to do hand calculations to investigate this problem\nfurther.\nThe anti-derivative is very easy to realize in this case:\n\n!bt\n\\begin{align*}\n\\int_0^1\\sin ((i+1)\\pi x/2)dx &= -\\frac{2}{\\pi(i+1)}(\\cos((i+1)\\frac{\\pi}{2}) - \\cos(0))\\\\ \n&= \\frac{2}{\\pi(i+1)}(1 - \\cos((i+1)\\frac{\\pi}{2})){\\thinspace .}\n\\end{align*}\n\n!et\nThe value of the cosine expression depends on $i$, and the first values are\n\n|-------------------------------|\n| $i=0$ | $i=1$ | $i=2$ | $i=3$ |\n|---c-------c-------c-------c---|\n| 0     | -1    | 0     |  1    |\n|-------------------------------|\n\nThis pattern repeats and is the same for four consecutive values of $i$.\nHence, the integral is $2/(\\pi (i+1))$ for even $i$ ($i=2k$ for\ninteger $k$, or equivalently: when $i\\mbox{ mod } 2 = 0$). For $i=4k+1$, or\nequivalently: when $(i-1)\\mbox{ mod } 4 = 0$, the\nintegral is $4/(\\pi(4k+1))$, while for $i=4k+3$, the integral vanishes.\nThis is a more complicated answer than what `sympy` provides!\n\nWe can check our new answers against numerical integration:\n\n!bc pycod\ndef check_integral_d():\n    from numpy import pi, sin\n    for i in range(24):\n        if i % 2 == 0:\n            exact = 2/(pi*(i+1))\n        elif (i-1) % 4 == 0:\n            exact = 2*2/(pi*(i+1))\n        else:\n            exact = 0\n        numerical = midpoint_rule(\n            f=lambda x: sin((i+1)*pi*x/2))\n        print(i, abs(exact - numerical))\n\n!ec\nThe output now is around $10^{-10}$ and we take that as a sign that\nour exact results are reliable.\n\n!bwarning Carefully check symbolic computations!\nThe example above shows how `sympy` can fail.\n"Wolfram Alpha": "http://wolframalpha.com" does a better job: writing\n`integrate sin(k*x*pi/2) from 0 to 1` (use `k` instead of `i` since the latter\nis the imaginary unit) returns the "result": "http://www.wolframalpha.com/input/?i=integrate+sin%28k*x*pi%2F2%29+from+0+to+1" $4\\sin^2(\\pi k/4)/(\\pi k)$,\nwhich coincides with out result.\n\nThere are three general techniques\nto verify a symbolic computation:\n\n * Use alternative software like Wolfram Alpha for comparison\n * Check that the result satisfies the problem to be solved\n * Make a high-resolution numerical approximation and compare\n\n(The second technique is not so applicable here, since we work with\na definite integral, but one could compute the indefinite integral\ninstead, which is done correctly by `sympy`, and discuss values for\n$x=1$.)\n!ewarning\n\nThe final result for $c_i$ is now\n\n!bt\n\\[ c_i = \\frac{b_i}{A_{i,i}} = \\left\\lbrace\\begin{array}{ll}\n-\\frac{16}{\\pi^3(i+1)^3}, & i\\hbox{ even, or } i \\hbox{ mod } 2 = 0\\\\ \n-\\frac{32}{\\pi^3(i+1)^3}, & (i-1)\\hbox{ mod } 4 = 0,\\\\ \n0, & (i+1)\\hbox{ mod } 4 = 0\n\\end{array}\\right.\n\\]\n\n!et\nWe recognize that for $i$ even, say $i=2k$ for integer $k$, we\nhave exactly the same result as in b):\n\n!bt\n\\[ -\\sum_k \\frac{16}{\\pi^3(2k+1)^3}\\sin((2k+1)x\\frac{\\pi x}{2}),\\]\n\n!et\nbut we get an additional set of terms for $i=4k+1$,\n\n!bt\n\\begin{equation}\n-\\sum_k \\frac{32}{\\pi^3(i+1)^3}\\sin((4k+1)x\\frac{\\pi x}{2}){\\thinspace .}\nlabel{fem:deq:exer:tension:cable:badterms}\n\\end{equation}\n\n!et\n\nWe can modify the software from c) to compute the approximate $u$\nwith the present set of basis functions and coefficients:\n\n!bc pycod\ndef sine_sum_d(x, N):\n    s = 0\n    from numpy import pi, sin, zeros\n    u = []  # u[k] is the sum i=0,...,k\n    k = 0\n    for i in range(N+1):\n        if i % 2 == 0:       # even i\n            s +=   - 16.0/((i+1)**3*pi**3)*sin((i+1)*pi*x/2)\n        elif (i-1) % 4 == 0:   # 1, 5, 9, 13, 17\n            s += - 2*16.0/((i+1)**3*pi**3)*sin((i+1)*pi*x/2)\n        else:\n            s += 0\n        u.append(s.copy())\n    return u\n\ndef plot_sine_sum_d():\n    from numpy import linspace\n    x = linspace(0, 1, 501)  # coordinates for plot\n    u = sine_sum_d(x, N=20)\n    u_e = 0.5*x*(x-2)\n    N_values = 0, 1, 2, 3, 20\n    for k in N_values:\n        plt.plot(x, u[k])\n    plt.plot(x, u_e)\n    plt.legend([\'N=%d\' % k for k in N_values] + [\'exact\'],\n               loc=\'upper right\')\n    plt.xlabel(\'$x$\');  plt.ylabel(\'$u$\')\n    #plt.axis([0.9, 1, -0.52, -0.49])\n    plt.savefig(\'tmpd.png\'); plt.savefig(\'tmpd.pdf\')\n\n!ec\nThe approximations for $N=0,1,3,20$ appear below.\n\nFIGURE: [fig/cable_sin_d, width=500 frac=0.8]\n\nWhile the approximation for $N=0$ coincides with the one in b), we\nsee that $N=1$ and higher values of $N$ lead to a clearly wrong curve.\nThis strange feature has to be investigated!\n\nLet us start by plotting the basis functions for $i=0,1,\\ldots,7$:\n\nFIGURE: [fig/sinix_int, width=800 frac=1]\n\nWe observe from the figure that all the basis functions corresponding to\neven $i$ are symmetric around $x=1$, which is an important property of\nthe solution. The functions for odd $i$ are anti-symmetric. However,\nfor $i=3,7,11,\\ldots$ the basis function has an integer number of\nperiods on $[0,1]$ so the integral becomes zero, $c_i=0$, and\nconsequently\nthere is no effect from these functions. The functions corresponding\nto $i=1,5,9,13,\\ldots$ are anti-symmetric around $x=1$ with nonzero\ncoefficients. The derivative of an anti-symmetric function at the point\nof anti-symmetry is unity in size. Since the derivatives of all the\nbasis functions corresponding to even $i$ vanish at $x=1$, the\nextra terms ($i=1,5,9,13,\\ldots$) in (ref{fem:deq:exer:tension:cable:badterms})\nhave a nonzero derivative, resulting in $u\'(1)\\neq 0$. That is,\nthese terms destroy the solution!\n\nBut we computed $c_i$ by a Galerkin method, which is equivalent to a\nleast squares method, which gives us the ``best\'\' approximation possible?\nThat is true, but it is the best approximation in the chosen space $V$.\nThe problem is that we have populated (or rather polluted) the space\n$V$ with some basis functions that have a wrong mathematical property: they\nare anti-symmetric around $x=1$.',
             'text': u"The functions in b) were selected such that they fulfill the\ncondition ${\\psi}'(1)=0$. However, in the Galerkin method, where we\nintegrate by parts, the condition $u'(1)=0$ is incorporated in the\nvariational form. This leads to the idea of just choosing a simpler\nbasis, namely ``all'' sine functions ${\\psi}_i = \\sin((i+1)\\frac{\\pi x}{2})$.\nWill the method adjust the coefficient such that the additional\nfunctions compared with those in b) get vanishing coefficients? Or\nwill the additional basis functions improve the solution?\nUse Galerkin's method."},
            {'aftertext': u'\n# BIG point: use polynomials, without integration by parts we cannot\n# handle the boundary condition.\n',
             'answer': '',
             'file': None,
             'hints': [],
             'solution': u"The formulas are almost the same as in d), only the integration domain\nis different. Since the sine functions or orthogonal on $[0,1]$, they\nare also orthogonal on $[0,2]$. Because\n\n!bc pyshell\n>>> integrate(cos((i+1)*pi*x/2)**2, (x, 0, 2))\n1\n\n!ec\nwe get (in Galerkin's method)\n\n!bt\n\\begin{align*}\nA_{i,i} &= (i+1)(j+1)\\frac{\\pi^2}{4}\\int_0^2 \\cos((i+1)\\frac{\\pi x}{2})\n\\cos((i+1)\\frac{\\pi x}{2})dx\\\\ \n& = (i+1)^2\\frac{\\pi^2}{4}{\\thinspace .}\n\\end{align*}\n\n!et\nand\n\n!bt\n\\[ b_i = -\\int_0^2 \\sin((i+1)\\frac{\\pi x}{2})dx = \\frac{2}{\\pi (i+1)}(\\cos((i+1)\\pi) - 1){\\thinspace .}\\]\n\n!et\nWe have that $\\cos((i+1)\\pi = -1$ for $i$ even and\n$\\cos((i+1)\\pi = 1$ for $i$ odd. That is,\n\n!bt\n\\[ b_i =\\left\\lbrace\\begin{array}{ll}\n-\\frac{4}{\\pi (i+1)}, & i\\hbox{ even }\\\\ \n0, & i\\hbox{ odd }\n\\end{array}\\right.\\]\n\n!et\nThe coefficients become\n\n!bt\n\\[ c_i =\\frac{b_i}{A_{i,i}} =\\left\\lbrace\\begin{array}{ll}\n-\\frac{16}{\\pi^3(i+1)^3}, & i\\hbox{ even }\\\\ \n0, & i\\hbox{ odd }\n\\end{array}\\right.\\]\n\n!et\nIntroducing $i=2k$ and then switching from $k$ to $i$ as summation index\ngives $c_i = -\\frac{16}{\\pi^3(2i+1)^3}$ and\n\n!bt\n\\[ u(x) = -\\sum_{i=0}^N \\frac{16}{\\pi^3(2i+1)^3}\\sin((i+1)\\frac{\\pi x}{2}),\\]\n\n!et\nwhich is the same expansion as in b).\n\nThe reason why the basis functions ${\\psi}_i=\\sin((i+1)\\frac{\\pi x}{2})$\nwork well in this case is that the problematic functions for $i=1,5,\\ldots$\nin d) now live on $[0,2]$ instead of $[0,1]$. On $[0,2]$ these functions\nhave an integer number of periods such that the integral from 0 to 2\nbecomes zero. These basis functions are therefore excluded from the\nexpansion since their coefficients vanish.\nThe lesson learned is that two equivalent boundary value\nproblems may make different demands to the basis functions.",
             'text': u"Now we drop the symmetry condition at $x=1$ and extend the domain to\n$[0,2]$ such that it covers the entire (scaled) physical cable. The\nproblem now reads\n\n!bt\n\\[ u'' = 1,\\quad x\\in (0,2),\\quad u(0)=u(2)=0{\\thinspace .}\\]\n\n!et\nThis time we need basis functions that are zero at $x=0$ and $x=2$.\nThe set $\\sin((i+1)\\frac{\\pi x}{2})$ from d) is a candidate since\nthey vanish $x=2$ for any $i$. Compute the approximation in this case.\nWhy is this approximation without the problem that this set of\nbasis functions introduced in d)?"}],
  'text': u"A hanging cable of length $L$\nwith significant tension $T$ has a deflection $w(x)$\ngoverned by\n\n!bt\n\\[\nT w''(x) = \\ell(x),\n\\]\n\n!et\nwhere $\\ell(x)$ the vertical load per unit length.\nThe cable is fixed at $x=0$ and $x=L$ so the boundary conditions become\n$w(0)=w(L)=0$. The deflection $w$ is positive upwards, and $\\ell$ is\npositive when it acts downwards.\n\nIf we assume a constant load $\\ell(x)=\\hbox{const}$,\nthe solution is expected to be symmetric around $x=L/2$. For a function\n$w(x)$ that is symmetric around some point $x_0$, it means that\n$w(x_0-h) = w(x_0+h)$, and then $w'(x_0)=\\lim_{h\\rightarrow 0}(w(x_0+h)-\nw(x_0-h))/(2h)=0$. We can therefore utilize symmetry to halve the domain.\nWe then seek $w(x)$ in $[0,L/2]$ with boundary conditions $w(0)=0$ and\n$w'(L/2)=0$.\n\nThe problem can be scaled by introducing dimensionless  variables,\n\n\n!bt\n\\[ \\bar x = \\frac{x}{L/2},\\quad \\bar u = \\frac{w}{w_c},\\]\n\n!et\nwhere $w_c$ is a characteristic size of $w$.\nInserted in the problem for $w$,\n\n!bt\n\\[ \\frac{4Tw_c}{L^{2}}\\frac{d^2\\bar u}{d\\bar x^2} = \\ell\\ (= \\hbox{const}){\\thinspace .}\\]\n\n!et\nA desire is to have $u$ and its derivatives about unity, so\nchoosing $w_c$ such that $|d^2\\bar u/d\\bar x^2|=1$ is an idea.\nThen $w_c=\\frac{1}{4}\\ell L^2/T$, and the problem for the scaled vertical\ndeflection $u$ becomes\n\n!bt\n\\[\nu'' = 1,\\quad x\\in (0,1),\\quad u(0)=0,\\ u'(1)=0{\\thinspace .}\n\\]\n\n!et\nObserve that there are no physical parameters in this scaled problem.\nFrom now on we have for convenience\nrenamed $x$ to be the scaled quantity $\\bar x$.",
  'title': u'Compute the deflection of a cable with sine functions',
  'type': u'Exercise',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': 3,
  'chapter_no': 1,
  'chapter_title': u'Variational formulations with global basis functions',
  'chapter_type': 'Chapter',
  'closing_remarks': '',
  'file': [u'cable_xn'],
  'heading': u'=====',
  'hints': [],
  'keywords': None,
  'label': u'fem:deq:exer:tension:cable_xn',
  'no': 3,
  'solution': '',
  'solution_file': None,
  'subex': [{'answer': '',
             'file': None,
             'hints': [u'Use the `solver` function from `varform1D.py`.'],
             'solution': u"The Galerkin formulation of $u''=1$, $u(0)=0$, $u'(1)=0$, reads\n\n!bt\n\\[ (u',v') = -(1,v)\\quad\\forall v\\in V,\\]\n\n!et\nand the linear system becomes\n\n!bt\n\\[ \\sum_{j=}^N ({\\psi}_i', {\\psi}_j')c_j = -(1,{\\psi}_i),\\quad i=0,1,\\ldots,N{\\thinspace .}\\]\n\n!et\nThe `varform1D.solver` function needs a function specifying the integrands\non the left- and right-hand sides of the variational formulation.\nMoreover, we must compute a dictionary of ${\\psi}_i$ and ${\\psi}_i'$.\nThe appropriate code becomes\n\n!bc pycod\nfrom varform1D import solver\nimport sympy as sym\nx, b = sym.symbols('x b')\nf = 1\n\n# Compute basis functions and their derivatives\nN = 4\npsi = {0: [x**(i+1) for i in range(N+1)]}\npsi[1] = [sym.diff(psi_i, x) for psi_i in psi[0]]\n\n# Galerkin\n\ndef integrand_lhs(psi, i, j):\n    return psi[1][i]*psi[1][j]\n\ndef integrand_rhs(psi, i):\n    return -f*psi[0][i]\n\nOmega = [0, 1]\n\nu, c = solver(integrand_lhs, integrand_rhs, psi, Omega,\n              verbose=True, symbolic=True)\nprint('Galerkin solution u:', sym.simplify(sym.expand(u)))\n\n!ec\nRunning this code gives the output\n\n!bc\nsolution u: x*(x - 2)/2\n\n!ec \nwhich coincides with the exact solution ($c_3=c_4=0$).",
             'text': u'Repeat Exercise ref{fem:deq:exer:tension:cable} b), but work with\nthe space\n\n!bt\n\\[ V = \\hbox{span}\\{x, x^2, x^3, x^4, \\ldots\\}{\\thinspace .} \\]\n\n!et\nChoose the dimension of $V$ to be 4 and observe that the exact solution\nis recovered by the Galerkin method.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': u"The least squares formulation leads to\n\n!bt\n\\[ (R,\\frac{\\partial R}{\\partial c_i}=0,\\quad i=0,\\ldots,N,\\]\n\n!et\nwith\n\n!bt\n\\[ R = 1 - u'' = 1 - \\sum_jc_j{\\psi}_j''{\\thinspace .}\\]\n\n!et\nWe have\n\n!bt\n\\[ \\frac{\\partial R}{\\partial c_i} = {\\psi}_i'',\\]\n\n!et\nleading to the equations\n\n!bt\n\\[ (1 + \\sum_jc_j{\\psi}_j'', {\\psi}_i''),\\quad i=0,\\ldots,N,\\]\n\n!et\nwhich is a linear system\n\n!bt\n\\[ \\sum_{j=0}^N({\\psi}_j'',{\\psi}_i'') = (-1,{\\psi}_i''),\\quad i=0,\\ldots,N{\\thinspace .}\\]\n\n!et\nThe fundamental problem with the basis in a) is that ${\\psi}_0''=0$, so\nif power functions of $x$ are wanted, we need to work with the basis\n$V=\\hbox{span}\\{x^2, x^3,\\ldots\\}$. If we do so, we can easily modify\nthe code from a),\n\n!bc pycod\n# Least squares\npsi = {0: [x**(i+2) for i in range(N+1)]}\npsi[1] = [sym.diff(psi_i, x) for psi_i in psi[0]]\npsi[2] = [sym.diff(psi_i, x) for psi_i in psi[1]]\n\ndef integrand_lhs(psi, i, j):\n    return psi[2][i]*psi[2][j]\n\ndef integrand_rhs(psi, i):\n    return -f*psi[2][i]\n\nOmega = [0, 1]\n\nu, c = solver(integrand_lhs, integrand_rhs, psi, Omega,\n              verbose=True, symbolic=True)\nprint('solution u:', sym.simplify(sym.expand(u)))\n\n!ec\nThe result is $u=-\\frac{1}{2} x^2$. This function does not obey $u'(1)=0$ and\nis completely wrong. In this least squares method we cannot access the basis\nfunction $x$, which is needed in the exact solution, and we have no means\nto obtain $u'(1)=0$.\n\n__Remark.__ There is a modification of the least squares method that\ncan be applied here. The\nproblem $u''=1$ must be rewritten as a system of two equations,\n$u_1'=u_2$, $u_2' =1$. We expand $u_1=\\sum_{j=0}^N c_j{\\psi}_j$ and\n$u_2=\\sum_{j=0}^N d_j{\\psi}_j$. The residuals in both equations are\nadded, squared, and differentiated with respect to $c_i$ and $d_i$,\n$i=0,\\ldots,N$. The result is a coupled equation system for the\n$c_i$ and $d_i$ coefficients.",
             'text': u'What happens if we use a least squares method for this problem with\nthe basis in a)?'}],
  'text': u'',
  'title': u'Compute the deflection of a cable with power functions',
  'type': u'Exercise',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': 4,
  'chapter_no': 1,
  'chapter_title': u'Variational formulations with global basis functions',
  'chapter_type': 'Chapter',
  'closing_remarks': '',
  'file': [u'cable_integr_by_parts'],
  'heading': u'=====',
  'hints': [],
  'keywords': None,
  'label': u'fem:deq:exer:intg:parts',
  'no': 4,
  'solution': u"The Galerkin method is\n\n!bt\n\\[ (u'',v)=(1,v)\\quad\\forall v\\in V,\\]\n\n!et\nand with the choice of $V$ we get\n\n!bt\n\\begin{align*}\nA_{i,j} &=-(i+1)^2\\pi^2 \\int_0^1\\sin^2((i+1)\\frac{\\pi x}{2})dx,\\\\ \nb_i &= \\int_0^1\\sin((i+1)\\frac{\\pi x}{2})dx\n\\end{align*}\n\n!et\nFrom Exercise ref{fem:deq:exer:tension:cable} we realize that\nthe integrals are the same as in the least squares method, and\nthose results were identical to those of the Galerkin method with\nintegration by parts.",
  'solution_file': None,
  'subex': [],
  'text': u'Consider the Galerkin method for the problem involving $u$\nin Exercise ref{fem:deq:exer:tension:cable}.\nShow that the formulas for $c_j$ are independent of whether we perform\nintegration by parts or not.',
  'title': u'Check integration by parts',
  'type': u'Exercise',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': 1,
  'chapter_no': 2,
  'chapter_title': u'Variational formulations with finite elements',
  'chapter_type': 'Chapter',
  'closing_remarks': '',
  'file': [u'cable_2P1'],
  'heading': u'=====',
  'hints': [],
  'keywords': None,
  'label': u'fem:deq:exer:cable:2P1',
  'no': 5,
  'solution': u"From Exercise ref{fem:deq:exer:tension:cable},\nthe Galerkin method, after integration by parts, reads\n\n!bt\n\\[ (u',v')=-(1,v)\\quad\\forall v\\in V{\\thinspace .}\\]\n\n!et\nWe have two elements,\n$\\Omega^{(0)}=[0,\\frac{1}{2}]$ and $\\Omega^{(1)}=[\\frac{1}{2},1]$.\n\n__Method 1: Excluding the unknown at $x=0$.__\nSince $u(0)=0$, we exclude the value at $x=0$ as degree of freedom in\nthe linear system. (There is no need for any boundary function.)\nThe expansion reads $u=c_0{\\varphi}_1(x) + c_1{\\varphi}_2(x)$.\nThe element matrix has then only one entry in the first element,\n\n!bt\n\\[ \\tilde A^{(0)} = \\frac{1}{h}(1){\\thinspace .}\\]\n\n!et\nFrom element 1 we get the usual element matrix\n\n!bt\n\\[ \\tilde A^{(1)} = \\frac{1}{h}\n\\left(\\begin{array}{rr}\n1 & -1\\\\ \n-1 & 1\n\\end{array}\\right){\\thinspace .}\n\\]\n\n!et\nThe element vector in element 0 becomes\n\n!bt\n\\[ \\tilde b^{(0)} = \\frac{h}{2}(-1),\\]\n\n!et\nwhile the second element gives a contribution\n\n!bt\n\\[ \\tilde b^{(1)} = \\frac{h}{2}\n\\left(\\begin{array}{c}\n-1 \\\\ \n-1\n\\end{array}\\right){\\thinspace .}\n\\]\n\n!et\nAssembling the contributions gives\n\n!bt\n\\[ \\frac{1}{h}\n\\left(\\begin{array}{cc}\n2 & -1\\\\ \n-1 & 1\n\\end{array}\\right)\n\\left(\\begin{array}{c}\nc_0 \\\\ \nc_1\n\\end{array}\\right)\n=\n- \\frac{h}{2}\n\\left(\\begin{array}{c}\n2 \\\\ \n1\n\\end{array}\\right){\\thinspace .}\n\\]\n\n!et\nNote that $h=\\frac{1}{2}$.\nSolving this system yields\n\n!bt\n\\[ c_0 = -\\frac{3}{8},\\quad c_1=-\\frac{1}{2}\\quad\\Rightarrow\\quad u=-\\frac{3}{8}{\\varphi}_1(x)-\\frac{1}{2}{\\psi}_2(x){\\thinspace .}\\]\n\n!et\nEvaluating the exact solution for $x=\\frac{1}{2}$ and $x=1$, we get $3/8$\nand $1/2$, respectively, a result which shows\nthat the numerical solution with P1 is exact at the three node points.\nThe difference between the numerical and exact solution is that the\nnumerical solution varies linearly over the two elements while the\nexact solution is quadratic.\n\n__Method 2: Modifying the linear system.__\nNow we let $c_i$ correspond to the value at node $x_{i}$, i.e.,\nall known Dirichlet values become part of the linear system.\nThe expansion is now simply $u=\\sum_{i=0}^2c_i{\\varphi}_i(x)$, with\nthree unknowns $c_0$, $c_1$, and $c_2$.\nNow the element matrix in the first and second element are equal.\nThe same is true for the element vectors.\nAssembling yields\n\n!bt\n\\[ \\frac{1}{h}\n\\left(\\begin{array}{ccc}\n1 & -1 & 0\\\\ \n-1 & 2 & -1\\\\ \n0 & -1 & 1\n\\end{array}\\right)\n\\left(\\begin{array}{c}\nc_0 \\\\ \nc_1\\\\ \nc_2\n\\end{array}\\right)\n=\n- \\frac{h}{2}\n\\left(\\begin{array}{c}\n1\\\\ \n2\\\\ \n1\n\\end{array}\\right){\\thinspace .}\n\\]\n\n!et\nThe next step is to modify the linear system to implement the\nDirichlet condition $c_0=0$. We first multiply by $h=\\frac{1}{2}$ and replace the\nfirst equation by $c_0=0$:\n\n!bt\n\\[\n\\left(\\begin{array}{ccc}\n1 & 0 & 0\\\\ \n-1 & 2 & -1\\\\ \n0 & -1 & 1\n\\end{array}\\right)\n\\left(\\begin{array}{c}\nc_0 \\\\ \nc_1\\\\ \nc_2\n\\end{array}\\right)\n=\n- \\left(\\begin{array}{c}\n0\\\\ \n\\frac{1}{4}\\\\ \n\\frac{1}{8}\n\\end{array}\\right){\\thinspace .}\n\\]\n\n!et\nWe see that the remaining $2\\times 2$ system is identical to the one\npreviously solved, and the solution is the same.\n\n!bt\n\\[ u = 0{\\varphi}_0(x) - \\frac{3}{8}{\\varphi}_1(x) - \\frac{1}{2}{\\psi}_2(x){\\thinspace .}\\]\n\n!et",
  'solution_file': None,
  'subex': [],
  'text': u'Solve the problem for $u$ in Exercise ref{fem:deq:exer:tension:cable}\nusing two P1 linear elements. Incorporate the condition $u(0)=0$\nby two methods: 1) excluding the unknown at $x=0$, 2) keeping the unknown\nat $x=0$, but modifying the linear system.',
  'title': u'Compute the deflection of a cable with 2 P1 elements',
  'type': u'Exercise',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': 2,
  'chapter_no': 2,
  'chapter_title': u'Variational formulations with finite elements',
  'chapter_type': 'Chapter',
  'closing_remarks': '',
  'file': [u'cable_1P2'],
  'heading': u'=====',
  'hints': [],
  'keywords': None,
  'label': u'fem:deq:exer:cable:1P2',
  'no': 6,
  'solution': u"The P2 basis functions on a reference element $[-1,1]$ are\n\n!bt\n\\begin{align*}\n{\\tilde{\\varphi}}_0(X) &= \\frac{1}{2} (X-1)X\n\\\\ \n{\\tilde{\\varphi}}_1(X) &= 1 - X^2\n\\\\ \n{\\tilde{\\varphi}}_2(X) &= \\frac{1}{2} (X+1)X\n\\end{align*}\n\n!et\nThe element matrix and vector are easily calculated by some lines with\n`sympy`:\n\n!bc pycod\nimport sympy as sym\nX, h = sym.symbols('X h')\nhalf = sym.Rational(1, 2)\npsi = [half*(X-1)*X, 1-X**2, half*(X+1)*X]\ndpsi_dX = [sym.diff(psi[r], X) for r in range(len(psi))]\n\n# Element matrix\n# (2/h)*dpsi_dX[r]*(2/h)*dpsi_dX[s]*h/2\nimport numpy as np\nd = 2\n# Use a numpy matrix with general objects to hold A\nA = np.empty((d+1, d+1), dtype=object)\nfor r in range(d+1):\n    for s in range(d+1):\n        integrand = dpsi_dX[r]*dpsi_dX[s]*2/h\n        A[r,s] = sym.integrate(integrand, (X, -1, 1))\nprint(A)\n\n# Element vector\n# f*psi[r]*h/2, f=1\nd = 2\nb = np.empty(d+1, dtype=object)\nfor r in range(d+1):\n    integrand = -psi[r]*h/2\n    b[r] = sym.integrate(integrand, (X, -1, 1))\nprint(b)\n\n!ec\nThe formatted element matrix and vector output becomes\n\n!bc\n[[7/(3*h) -8/(3*h) 1/(3*h)]\n [-8/(3*h) 16/(3*h) -8/(3*h)]\n [1/(3*h) -8/(3*h) 7/(3*h)]]\n[-h/6 -2*h/3 -h/6]\n\n!ec \nor in mathematical notation:\n\n!bt\n\\[ \\tilde A^{(e)}=\\frac{1}{3h}\n\\left(\\begin{array}{ccc}\n7 & -8 & 1\\\\ \n-8 & 16 & -8\\\\ \n1 & -8 & 7\n\\end{array}\\right),\\quad\n\\tilde b^{(e)} = - \\frac{h}{6}\n\\left(\\begin{array}{c}\n1\\\\ \n4\\\\ \n1\n\\end{array}\\right){\\thinspace .}\n\\]\n\n!et\n\n__Method 1: Excluding the unknown at $x=0$.__\nThe expansion is $u=c_0{\\varphi}_1(x) + c_1{\\varphi}_2(x)$. The element matrix\ncorresponding to the first element excludes contributions associated with\nthe unknown at the left node, i.e., we exclude row and column 0. In the\nelement vector, we exclude the first entry.\n\n!bt\n\\[ \\tilde A^{(0)}=\\frac{1}{3h}\n\\left(\\begin{array}{cc}\n16 & -8\\\\ \n-8 & 7\n\\end{array}\\right),\\quad\n\\tilde b^{(e)} = - \\frac{h}{6}\n\\left(\\begin{array}{c}\n4\\\\ \n1\n\\end{array}\\right){\\thinspace .}\n\\]\n\n!et\nNow, $h=1$.\nThe solution of the linear system\n\n!bt\n\\[ \\frac{1}{3h}\n\\left(\\begin{array}{cc}\n16 & -8\\\\ \n-8 & 7\n\\end{array}\\right)\n\\left(\\begin{array}{c}\nc_1\\\\ \nc_2\n\\end{array}\\right)\n=\n- \\frac{h}{6}\n\\left(\\begin{array}{c}\n4\\\\ \n1\n\\end{array}\\right)\n\\]\n\n!et\nis $c_1=3/8$ and $c_2=1/2$. As for P1 elements in Exercise\nref{fem:deq:exer:cable:2P1}, the values at the nodes are exact, but\nthis time the variation between the nodes is quadratic, i.e., exact.\nOne P2 element produces the complete, exact solution.\n\n__Method 2: Modifying the linear system.__\nThis time the expansion reads $u=\\sum_{i=0}^2 c_i{\\varphi}_i(x)$ with\nthree unknowns $c_0$, $c_1$, and $c_2$. The linear system consists\nof the complete $3\\times 3$ element matrix and the corresponding\nelement vector:\n\n!bt\n\\[ \\frac{1}{3h}\n\\left(\\begin{array}{ccc}\n7 & -8 & 1\\\\ \n-8 & 16 & -8\\\\ \n1 & -8 & 7\n\\end{array}\\right)\n\\left(\\begin{array}{c}\nc_0\\\\ \nc_1\\\\ \nc_2\n\\end{array}\\right)\n=\n- \\frac{h}{6}\n\\left(\\begin{array}{c}\n1\\\\ \n4\\\\ \n1\n\\end{array}\\right){\\thinspace .}\n\\]\n\n!et\nThe boundary condition is incorporated by replacing the first equation\nby $c_0=0$, but prior to taking that action, we multiply by $3h$ and\ninsert $h=1$.\n\n!bt\n\\[\n\\left(\\begin{array}{ccc}\n1 & 0 & 0   \\\\ \n-8 & 16 & -8\\\\ \n1 & -8 & 7\n\\end{array}\\right)\n\\left(\\begin{array}{c}\nc_0\\\\ \nc_1\\\\ \nc_2\n\\end{array}\\right)\n=\n\\left(\\begin{array}{c}\n0\\\\ \n- 2\\\\ \n- \\frac{1}{2}\n\\end{array}\\right){\\thinspace .}\n\\]\n\n!et\nRealizing that $c_0=0$, which means we can remove the first column of\nthe system, shows that the equations are the same as above and hence\nthat the solution is identical.",
  'solution_file': None,
  'subex': [],
  'text': u'Solve the problem for $u$ in Exercise ref{fem:deq:exer:tension:cable}\nusing one P2 element with quadratic basis functions.',
  'title': u'Compute the deflection of a cable with 1 P2 element',
  'type': u'Exercise',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': 3,
  'chapter_no': 2,
  'chapter_title': u'Variational formulations with finite elements',
  'chapter_type': 'Chapter',
  'closing_remarks': '',
  'file': [u'cable_discont_load'],
  'heading': u'=====',
  'hints': [],
  'keywords': None,
  'label': u'fem:deq:exer:cable:stepload',
  'no': 7,
  'solution': '',
  'solution_file': None,
  'subex': [{'answer': '',
             'file': None,
             'hints': [u"Integrate the equation separately for $x < 1$ and $x>1$. Use\nthe conditions that $u$ and $u'$ must be continuous at $x=1$."],
             'solution': u"For $x < 1$ we get $u_1(x) = C_1x + C_2$, and the boundary condition\n$u_1(0)=0$ implies $C_2=0$. For $x>1$ we get $u_2(x)=\\frac{1}{2} x^2 + C_3x + C_4$.\nContinuity of $u'(1)$ leads to\n\n!bt\n\\[ C_1 = 1 + C_3,\\]\n\n!et\nand continuity of $u(1)$ means\n\n!bt\n\\[  C_1 = \\frac{1}{2} + C_3 + C_4,\\]\n\n!et\nwhile the condition $u_2(2)=0$ gives the third equation we need:\n\n!bt\n\\[ 2 + 2C_3 + C_4 = 0{\\thinspace .}\\]\n\n!et\nWe use `sympy` to solve them:\n\n!bc pyshell\n>>> from sympy import symbols, Rational, solve\n>>> C1, C3, C4 = symbols('C1 C3 C4')\n>>> solve([C1 - 1 - C3,\n           C1 - Rational(1,2) - C3 - C4,\n\t   2 + 2*C3 + C4], [C1,C3,C4])\n{C1: -1/4, C4: 1/2, C3: -5/4}\n\n!ec\nThen\n\n!bt\n\\[ u(x) = \\left\\lbrace\\begin{array}{ll}\n-\\frac{1}{4}x, & x\\leq 1,\\\\ \n\\frac{1}{2} x^2 - \\frac{5}{4}x + \\frac{1}{2}, & x\\geq 1\n\\end{array}\\right.\n\\]\n\n!et\n\nFIGURE: [fig/cable_discont_load_u_exact, width=500 frac=0.8]",
             'text': u'Find the analytical solution of the problem.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': u"The Galerkin formulation of the problem becomes\n\n!bt\n\\[ (u',v') = -(\\bar\\ell, v) = \\left\\lbrace\\begin{array}{ll}\n0, & x\\leq 1,\\\\ \n-(1,v), & x\\geq 1\n\\end{array}\\right.\\quad\\forall v\\in V{\\thinspace .}\\]\n\n!et\nA requirement is that $v(0)=v(2)=0$ because of the boundary conditions\non $u$. The chosen basis functions\nfulfill this requirement for any integer $i$. Inserting\n$u=\\sum_{j=0}^N c_j{\\psi}_j$ and $v={\\psi}_i$, $i=0,\\ldots,N$,\ngives as usual the linear system $\\sum_j A_{i,j}c_j = b_i$, $i=0,\\ldots,N$,\nwhere\n\n!bt\n\\[\nA_{i,j} = (i+1)(j+1)\\frac{\\pi^2}{4}\\int_0^2 \\cos((i+1)\\frac{\\pi x}{2})\n\\cos((j+1)\\frac{\\pi x}{2})dx{\\thinspace .}\\]\n\n!et\nThe cosine functions are orthogonal on $[0,2]$ so $A_{i,j}=0$ for\n$i\\neq j$, while $A_{i,i}$ is computed (e.g., by `sympy`) as in\nExercise ref{fem:deq:exer:tension:cable}, part e. The result is\n\n!bt\n\\[ A_{i,i} = (i+1)^2\\frac{\\pi^2}{4}{\\thinspace .}\\]\n\n!et\nThe right-hand side is\n\n!bt\n\\[ b_i =\n-\\int_1^2 \\sin((i+1)\\frac{\\pi x}{2})dx\n= \\frac{2}{\\pi (i+1)}(\\cos((i+1)\\pi) - \\cos((i+1)\\pi/2)){\\thinspace .}\\]\n\n!et\n(Trying to do the integral in `sympy` gives a complicated expression that\nneeds discussion - it\nis easier to do all calculations by hand.)\nWe have that $\\cos((i+1)\\pi = -1$ for $i$ even and\n$\\cos((i+1)\\pi = 1$ for $i$ odd, while $\\cos((i+1)\\pi/2)$ is\ndiscussed in\nExercise ref{fem:deq:exer:tension:cable}, part d. The values\nof $\\cos((i+1)\\pi) - \\cos((i+1)\\pi/2)$ can be summarized in the following\ntable:\n\n|-------------------------------|\n| $i\\hbox{ mod } 4 = 0$ | $(i-1)\\hbox{ mod } 4 = 0$ | $(i-2)\\hbox{ mod } 4 = 0$ | $(i-3)\\hbox{ mod } 4 = 0$ |\n|---c-------c-------c-------c---|\n| $-1 -0$     |  $1 - (-1)$    | $-1 - 0$     |  $1-1$  |\n|-------------------------------|\n\nThe following function computes the approximate solution:\n\n!bc pycod\ndef sine_solution(x, N):\n    from numpy import pi, sin\n    s = 0\n    u = [] # u[i] is the solution for N=i\n    for i in range(N+1):\n        if i % 4 == 0:\n            cos_min_cos = -1\n        elif (i-1) % 4 == 0:\n            cos_min_cos = 2\n        elif (i-2) % 4 == 0:\n            cos_min_cos = -1\n        elif (i-1) % 4 == 0:\n            cos_min_cos = 0\n\n        b_i = 2/(pi*(i+1))*cos_min_cos\n        A_ii = (i+1)**2*pi**2/4\n        c_i = b_i/A_ii\n        s += c_i*sin((i+1)*x*pi/2)\n        u.append(s.copy())\n    return u\n\n!ec\n\nThe exact solution is a function defined in a piecewise way. Below we make an implementation that works both for array and scalar arguments:\n\n!bc pycod\ndef exact_solution(x):\n    if isinstance(x, np.ndarray):\n        return np.where(x < 1, -1./4*x, 0.5*x**2 - 5./4*x + 0.5)\n    else:\n        return -1./4*x if x < 1 else 0.5*x**2 - 5./4*x + 0.5\n\n!ec\nNow we can make a plot of the exact solution and approximate solutions for\nvarious $N$:\n\n!bc pycod\ndef plot_sine_solution():\n    x = np.linspace(0, 2, 101)\n    u = sine_solution(x, N=20)\n    plt.figure()\n    x = np.linspace(0, 2, 101)\n    plt.plot(x, exact_solution(x), '--')\n    N_values = 0, 1, 5\n    for N in 0, 1, 5, 10:\n        plt.plot(x, u[N])\n    plt.legend(['exact'] + ['N=%d' % N for N in N_values])\n    plt.savefig('tmp2.png');  plt.savefig('tmp2.pdf')\n\n!ec\n\nFIGURE: [fig/cable_discont_load_sines, width=500 frac=0.8]",
             'text': u'Use ${\\psi}_i = \\sin((i+1)\\frac{\\pi x}{2})$,\n$i=0,\\ldots,N$ and the Galerkin method to find an approximate\nsolution $u=\\sum_j c_j{\\psi}_j$.\nPlot how fast the coefficients $c_j$ tend to zero (on a log scale).'},
            {'aftertext': u'\n\n',
             'answer': '',
             'file': None,
             'hints': [],
             'solution': u"The element matrices and vectors are as for the well-known model\nproblem $u''=1$, except that the element vectors vanish for all\nelements in $[0,1]$. The following function defines a uniform mesh\nof P1 elements and runs a finite element algorithm where we use\nready-made/known formulas for the element matrix and vector:\n\n!bc pycod\ndef P1_solution():\n    plt.figure()\n    from fe1D import mesh_uniform, u_glob\n    N_e_values = [2, 4, 8]\n    d = 1\n    legends = []\n    for N_e in N_e_values:\n        vertices, cells, dof_map = mesh_uniform(\n            N_e=N_e, d=d, Omega=[0,2], symbolic=False)\n        h = vertices[1] - vertices[0]\n        Ae = 1./h*np.array(\n            [[1, -1],\n             [-1, 1]])\n        N = N_e + 1\n        A = np.zeros((N, N))\n        b = np.zeros(N)\n        for e in range(N_e):\n            if vertices[e] >= 1:\n                be = -h/2.*np.array(\n                    [1, 1])\n            else:\n                be = h/2.*np.array(\n                    [0, 0])\n            for r in range(d+1):\n                for s in range(d+1):\n                    A[dof_map[e][r], dof_map[e][s]] += Ae[r,s]\n                b[dof_map[e][r]] += be[r]\n        # Enforce boundary conditions\n        A[0,:] = 0; A[0,0] = 1; b[0] = 0\n        A[-1,:] = 0; A[-1,-1] = 1; b[-1] = 0\n        c = np.linalg.solve(A, b)\n\n        # Plot solution\n        print('c:', c)\n        print('vertices:', vertices)\n        print('cells:', cells)\n        print('len(cells):', len(cells))\n        print('dof_map:', dof_map)\n        xc, u, nodes = u_glob(c, vertices, cells, dof_map)\n        plt.plot(xc, u)\n        legends.append('$N_e=%d$' % N_e)\n    plt.plot(xc, exact_solution(xc), '--')\n    legends.append('exact')\n    plt.legend(legends, loc='lower left')\n    plt.savefig('tmp3.png'); plt.savefig('tmp3.pdf')\n\n!ec\n\nFIGURE: [fig/cable_discont_load_P1, width=500 frac=0.8]",
             'text': u'Solve the problem with P1 finite elements.\nPlot the solution for $N_e=2,4,8$ elements.'}],
  'text': u"We consider the deflection of a tension cable as described in\nExercise ref{fem:deq:exer:tension:cable}: $w''=\\ell$, $w(0)=w(L)=0$.\nNow the load is discontinuous:\n\n!bt\n\\[ \\ell (x) =\\left\\lbrace\\begin{array}{ll}\n\\ell_1, & x < L/2,\\\\ \n\\ell_2, & x \\geq L/2\n\\end{array}\\right.\\quad x\\in [0,L]\n{\\thinspace .}\n\\]\n\n!et\nThis load is not symmetric\nwith respect to the midpoint $x=L/2$ so the solution loses its symmetry.\nScaling the problem by introducing\n\n!bt\n\\[ \\bar x = \\frac{x}{L/2},\\quad u = \\frac{w}{w_c},\\quad\\bar\\ell = \\frac{\\ell - \\ell_1}{\\ell_2 - \\ell_1}{\\thinspace .}\\]\n\n!et\nThis leads to a scaled problem on $[0,2]$ (we rename $\\bar x$ as $x$\nfor convenience):\n\n!bt\n\\[ u'' = \\bar\\ell(x) = \\left\\lbrace\\begin{array}{ll}\n1, & x < 1,\\\\ \n0, & x \\geq 1\n\\end{array}\\right.\n\\quad x\\in (0,1),\\quad u(0)=0,\\ u(2)=0\n{\\thinspace .} \\]\n\n!et",
  'title': u'Compute the deflection of a cable with a step load',
  'type': u'Exercise',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': 4,
  'chapter_no': 2,
  'chapter_title': u'Variational formulations with finite elements',
  'chapter_type': 'Chapter',
  'closing_remarks': '',
  'file': [u'nonuniform_P1'],
  'heading': u'=====',
  'hints': [],
  'keywords': None,
  'label': u'fem:deq:exer:1D:mesh:nonuniform',
  'no': 8,
  'solution': '',
  'solution_file': None,
  'subex': [{'aftertext': u'\n',
             'answer': '',
             'file': None,
             'hints': [],
             'solution': u'The element matrix and vector for this problem is given by\n(ref{fem:deq:1D:ex1:Ab:elm}). The change in this exercise is that\n$h$ is not a constant element length, but varying with the element\nnumber $e$. We therefore write\n\n!bt\n\\[\n\\tilde A^{(e)} =\\frac{1}{h_e}\\left(\\begin{array}{rr}\n1 & -1\\\\ \n-1 & 1\n\\end{array}\\right),\\quad\n\\tilde b^{(e)} = h_e\\left(\\begin{array}{c}\n1\\\\ \n1\n\\end{array}\\right){\\thinspace .}\n\\]\n\n!et\nAssembling such element matrices yields\n\n!bt\n\\[\n\\left(\n\\begin{array}{ccccccccc}\nh_0^{-1} & -h_0^{-1} & 0 &\\cdots & \\cdots & \\cdots & \\cdots & \\cdots & 0 \\\\ \n-h_0^{-1} & h_0^{-1}+h_1^{-1} & -h_1^{-1} & \\ddots &   & &  & &  \\vdots \\\\ \n0 & -h_1^{-1} & h_1^{-1} + h_2^{-1} & -h_2^{-1} &\n\\ddots & &  &  & \\vdots \\\\ \n\\vdots & \\ddots &  & \\ddots & \\ddots & 0 &  & & \\vdots \\\\ \n\\vdots &  & \\ddots & \\ddots & \\ddots & \\ddots & \\ddots & & \\vdots \\\\ \n\\vdots & &  & 0 & -h_{i-1}^{-1} & h_{i-1}^{-1} + h_i^{-1} & -h_i^{-1} & \\ddots & \\vdots \\\\ \n\\vdots & & &  & \\ddots & \\ddots & \\ddots &\\ddots  & 0 \\\\ \n\\vdots & & & &  &\\ddots  & \\ddots &\\ddots  & -h_{N_e}^{-1} \\\\ \n0 &\\cdots & \\cdots &\\cdots & \\cdots & \\cdots  & 0 & -h_{N_e}^{-1} & h_{N_e}^{-1}\n\\end{array}\n\\right)\n\\]\n\n!et\nThe element vectors assemble to\n\n!bt\n\\[\n\\left(\n\\begin{array}{c}\nh_0 \\\\ \nh_0 + h_1\\\\ \n\\vdots\\\\ \n\\vdots \\\\ \n\\vdots \\\\ \nh_{i-1} + h_i\\\\ \n\\vdots \\\\ \n\\vdots\\\\ \nh_{N_e}\n\\end{array}\n\\right)\n\\]\n\n!et',
             'text': u"Derive the linear system for the problem $-u''=2$ on $[0,1]$, with\n$u(0)=0$ and $u(1)=1$, using P1 elements and a *non-uniform* mesh. The\nvertices have coordinates $x_{0}=0 < x_{1} <\\cdots <\nx_{N_n-1}=1$, and the length of cell number $e$ is $h_e = x_{e+1}\n-x_{e}$."},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': u"Using the definition of the centered, 2nd-order finite difference approximation\nto $u''$ we can set up\n\n!bt\n\\[ [D_xD_x u]_i = [D_x(D_x u)]_i = \\frac{\\frac{u_{i+1}-u_i}{x_{i+1}-x_i} -\n\\frac{u_{i}-u_{i-1}}{x_{i}-x_{i-1}}}{x_{i+1/2} - x_{i-1/2}}{\\thinspace .}\\]\n\n!et\nNow,\n\n!bt\n\\[ x_{i+1/2} - x_{i-1/2} = \\frac{1}{2} (x_i - x_{i-1}) + \\frac{1}{2}(x_{i+1}-x_i) = \\frac{1}{2}(x_{i+1}-x_{i-1}){\\thinspace .}\\]\n\n!et\nWe then get the difference equation\n\n!bt\n\\[ u''(x_i)\\approx \\frac{2}{h_i + h_{i-1}}\\left(\n\\frac{u_{i+1}-u_i}{h_{i}} - \\frac{u_{i}-u_{i-1}}{h_{i-1}}\\right) = 2{\\thinspace .}\\]\n\n!et\nThe factor 2 on either side cancels.\n\nLooking at the finite element equations in a), the equation for a general\nrow $i$ reads\n\n!bt\n\\[ \\frac{1}{h_{i-1}}c_{i-1} - (\\frac{1}{h_{i-1}} + \\frac{1}{h_{i}})c_i\n+ \\frac{1}{h_{i}}c_{i+1} = h_{i-1} + h_i{\\thinspace .}\\]\n\n!et\nReplacing $c_i$ by $u_i$ (assuming we keep unknowns at all nodes) and\nrearranging gives\n\n!bt\n\\[ -\\frac{1}{h_{i-1}}(u_i - u_{i-1}) + \\frac{1}{h_{i}}(u_{i+1}-u_i)\n = h_{i-1} + h_i{\\thinspace .}\\]\n\n!et\nDividing by the right-hand side gives\n\n!bt\n\\[ -\\frac{1}{h_{i-1} + h_i}\\left(\\frac{1}{h_{i-1}}(u_i - u_{i-1}) - \\frac{1}{h_{i}}(u_{i+1}-u_i)\\right) = 1{\\thinspace .}\\]\n\n!et\nThis is the same difference equation as we have in the finite difference\nmethod.",
             'text': u"It is of interest to compare the discrete equations for the finite\nelement method in a non-uniform mesh with the corresponding discrete\nequations arising from a finite difference method. Go through the\nderivation of the finite difference formula $u''(x_i) \\approx [D_x D_x\nu]_i$ and modify it to find a natural discretization of $u''(x_i)$ on\na non-uniform mesh. Compare the finite element and difference\ndiscretizations"}],
  'text': u'',
  'title': u'Compute with a non-uniform mesh',
  'type': u'Exercise',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': 5,
  'chapter_no': 2,
  'chapter_title': u'Variational formulations with finite elements',
  'chapter_type': 'Chapter',
  'closing_remarks': '',
  'file': [u'convdiff1D_P1'],
  'heading': u'=====',
  'hints': [],
  'keywords': None,
  'label': u'fem:deq:exer:1D:gen:problem1',
  'no': 9,
  'solution': '',
  'solution_file': None,
  'subex': [{'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': u"Find the analytical solution to this problem.\n(Introduce $w=u'$, solve the first-order differential equation for $w(x)$,\nand integrate once more.)"},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': u'Derive the variational form of this problem.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': u'Introduce a finite element mesh with uniform partitioning.\nUse P1 elements and compute the element matrix and vector for\na general element.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': u'Incorporate the boundary conditions and\nassemble the element contributions.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': u'Identify the resulting linear system as a finite difference discretization\nof the differential equation using\n\n!bt\n\\[ [D_{2x}u = \\epsilon D_xD_x u]_i {\\thinspace .}  \\]\n\n!et'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': u'Compute the numerical solution and plot it together with the exact solution\nfor a mesh with 20 elements and\n$\\epsilon=10, 1, 0.1, 0.01$.'}],
  'text': u"The following scaled 1D problem is a very simple, yet relevant, model\nfor convective transport in fluids:\n\n!bt\n\\begin{equation}\nu' = \\epsilon u'' ,\\quad u(0)=0,\\ u(1)=1,\\ x\\in [0,1]\n{\\thinspace .}\nlabel{_auto47}\n\\end{equation}\n\n!et",
  'title': u'Solve a 1D finite element problem by hand',
  'type': u'Problem',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': 6,
  'chapter_no': 2,
  'chapter_title': u'Variational formulations with finite elements',
  'chapter_type': 'Chapter',
  'closing_remarks': '',
  'file': [u'u_xx_xm_P1to4'],
  'heading': u'=====',
  'hints': [u'Use the `mesh_uniform`, `finite_element1D`, and `u_glob2` functions\nfrom the `fe1D.py` module.'],
  'keywords': None,
  'label': u'fem:deq:exer:1D:exact_numerics',
  'no': 10,
  'solution': u"The `model2` function from Section ref{fem:deq:1D:models:simple}\ncan find the exact solution by `model2(x**m, L, C, D)`.\nWe fix, for simplicity, the values of $L$, $C$, and $D$ as\n$L=4$, $C=5$, and $D=2$.\nAfter calculating a symbolic solution, we can convert the expression\nto a Python function with `sympy.lambdify`.\nFor each $d$ value we then create a uniform mesh and displace the\nvertex with number 1 to the value 3.\nThe various functions for specifying the element matrix and vector\nentries are as given in Section ref{fem:deq:1D:code:fe_sparse},\nsince the model problem is the same. Our code then becomes\n\n!bc pycod\nfrom u_xx_f_sympy import model2, x\nimport sympy as sym\nimport numpy as np\nfrom fe1D import finite_element1D, mesh_uniform, u_glob\nimport matplotlib.pyplot as plt\n\nC = 5\nD = 2\nL = 4\n\nm_values = [0, 1, 2, 3, 4]\nd_values = [1, 2, 3, 4]\nfor m in m_values:\n    u = model2(x**m, L, C, D)\n    print('\\nm=%d, u: %s' % (m, u))\n    u_exact = sym.lambdify([x], u)\n\n    for d in d_values:\n        vertices, cells, dof_map = mesh_uniform(\n            N_e=2, d=d, Omega=[0,L], symbolic=False)\n        vertices[1] = 3  # displace vertex\n        essbc = {}\n        essbc[dof_map[-1][-1]] = D\n\n        c, A, b, timing = finite_element1D(\n            vertices, cells, dof_map,\n            essbc,\n            ilhs=lambda e, phi, r, s, X, x, h:\n            phi[1][r](X, h)*phi[1][s](X, h),\n            irhs=lambda e, phi, r, X, x, h:\n            x**m*phi[0][r](X),\n            blhs=lambda e, phi, r, s, X, x, h: 0,\n            brhs=lambda e, phi, r, X, x, h:\n            -C*phi[0][r](-1) if e == 0 else 0,\n            intrule='GaussLegendre')\n\n        # Visualize\n        # (Recall that x is a symbol, use xc for coordinates)\n        xc, u, nodes = u_glob(c, vertices, cells, dof_map)\n        u_e = u_exact(xc)\n        print('Max diff at nodes, d=%d:' % d, \\ \n              np.abs(u_exact(nodes) - c).max())\n        plt.figure()\n        plt.plot(xc, u, 'b-', xc, u_e, 'r--')\n        plt.legend(['finite elements, d=%d' %d, 'exact'],\n                   loc='lower left')\n        figname = 'tmp_%d_%d' % (m, d)\n        plt.savefig(figname + '.png'); plt.savefig(figname + '.pdf')\n\n!ec\n\nFirst we look at the numerical solution at the nodes:\n\n!bc\nm=0, u: -x**2/2 + 5*x - 10\nMax diff at nodes, d=1: 2.22044604925e-16\nMax diff at nodes, d=2: 3.5527136788e-15\nMax diff at nodes, d=3: 1.7763568394e-15\nMax diff at nodes, d=4: 2.46913600677e-13\n\nm=1, u: -x**3/6 + 5*x - 22/3\nMax diff at nodes, d=1: 8.881784197e-16\nMax diff at nodes, d=2: 1.7763568394e-15\nMax diff at nodes, d=3: 7.9936057773e-15\nMax diff at nodes, d=4: 3.01092484278e-13\n\nm=2, u: -x**4/12 + 5*x + 10/3\nMax diff at nodes, d=1: 3.10862446895e-15\nMax diff at nodes, d=2: 0.084375\nMax diff at nodes, d=3: 0.0333333333333\nMax diff at nodes, d=4: 5.20472553944e-13\n\nm=3, u: -x**5/20 + 5*x + 166/5\nMax diff at nodes, d=1: 1.35555555556\nMax diff at nodes, d=2: 0.3796875\nMax diff at nodes, d=3: 0.185714285714\nMax diff at nodes, d=4: 0.0254255022334\n\nm=4, u: -x**6/30 + 5*x + 1778/15\nMax diff at nodes, d=1: 4.8\nMax diff at nodes, d=2: 1.4428125\nMax diff at nodes, d=3: 0.719047619047\nMax diff at nodes, d=4: 0.16865583147\n\n!ec \nWe observe that all elements are capable of computing the exact values\nat the nodes for $m=0$ and $m=1$. With $m=0$, the solution is quadratic\nin $x$, and P2, P3, and P4 will be exact. It is more of a surprise that\nalso the P1 elements are exact in this case.\nA peculiar feature is that P1\nelements are also exact at the nodes $m=2$, but not P2 and P3 elements\n(the solution goes like $x^4$ so it is not surprising that P2 and P3\nelements give a numerical error also at the nodes).\nClearly, P4 elements produce the exact solution for $m=4$ since $u$\nis a polynomial of degree 4. For larger $m$ values we have\ndiscrepancy between the numerical and exact values at the nodes.\n\n% for m in [0, 1, 2, 3, 4]:\n\n__Plots for m=${m}.__\n\nFIGURE: [fig/u_xx_xm${m}_P1to4, width=800 frac=1]\n% endfor",
  'solution_file': None,
  'subex': [],
  'text': u"Consider\n\n!bt\n\\[ -u''(x)=x^m,\\quad x\\in (0,L),\\quad u'(0)=C,\\ u(L)=D,\\]\n\n!et\nwhere $m\\geq 0$ is an integer, and $L$, $C$, and $D$ are given numbers.\nUtilize a mesh with two (non-uniform) elements: $\\Omega^{(0)}=[0,3]$ and\n$\\Omega^{(0)}=[3,4]$.\nPlot the exact solution and the finite element solution for\npolynomial degree $d=1,2,3,4$ and $m=0, 1, 2, 3, 4$. Find values of $d$ and $m$\nthat make the finite element solution exact at the nodes in the mesh.",
  'title': u'Investigate exact finite element solutions',
  'type': u'Exercise',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': 7,
  'chapter_no': 2,
  'chapter_title': u'Variational formulations with finite elements',
  'chapter_type': 'Chapter',
  'closing_remarks': '',
  'file': [u'radial_Poisson1D_P1'],
  'heading': u'=====',
  'hints': [],
  'keywords': None,
  'label': u'fem:deq:exer:1D:Poisson:polar',
  'no': 11,
  'solution': '',
  'solution_file': None,
  'subex': [{'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': u'Derive a variational form of (ref{fem:deq:exer:1D:Poisson:polar:eq})\nby integrating over the whole disk, or posed equivalently: use\na weighting function $2\\pi r v(r)$ and integrate $r$ from $0$ to $R$.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': u'Use a uniform mesh partition with P1 elements and show what the\nresulting set of equations becomes. Integrate the matrix entries\nexact by hand, but use a Trapezoidal rule to integrate the $f$ term.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': u"Explain that an intuitive\nfinite difference method applied to (ref{fem:deq:exer:1D:Poisson:polar:eq})\ngives\n\n!bt\n\\[\n\\frac{1}{r_i}\\frac{1}{h^2}\\left( r_{i+\\frac{1}{2}}(u_{i+1}-u_i) -\nr_{i-\\frac{1}{2}}(u_{i}-u_{i-1})\\right) = f_i,\\quad i=rh\n{\\thinspace .}\n\\]\n\n!et\n\nFor $i=0$ the factor $1/r_i$ seemingly becomes problematic. One must always\nhave $u'(0)=0$, because of the radial symmetry, which implies\n$u_{-1}=u_1$, if we allow introduction of a fictitious value $u_{-1}$.\nUsing this $u_{-1}$ in the difference equation for $i=0$ gives\n\n!bt\n\\begin{align*}\n&\\frac{1}{r_0}\\frac{1}{h^2}\\left( r_{\\frac{1}{2}}(u_{1}-u_0) -\nr_{-\\frac{1}{2}}(u_{0}-u_{1})\\right) = \\\\ \n& \\qquad\n\\frac{1}{r_0}\\frac{1}{2h^2}\\left( (r_0 + r_1)(u_{1}-u_0) -\n(r_{-1} + r_0)(u_{0}-u_{1})\\right) \\approx\n2(u_1-u_0),\n\\end{align*}\n\n!et\nif we use $r_{-1}+r_1\\approx 2r_0$.\n\nSet up the complete set of equations for the finite difference method\nand compare to the finite element method in case a Trapezoidal rule\nis used to integrate the $f$ term in the latter method."}],
  'text': u"We consider the Poisson problem in a disk with radius $R$ with\nDirichlet conditions at the boundary.\nGiven that the solution is radially symmetric and hence dependent only on\nthe radial coordinate ($r=\\sqrt{x^2+y^2}$), we can reduce the problem\nto a 1D Poisson equation\n\n!bt\n\\begin{equation}\n-\\frac{1}{r}\\frac{d}{dr}\\left( r\\frac{du}{dr}\\right) = f(r),\\quad r\\in (0,R),\\ \nu'(0)=0,\\ u(R)=U_R\n{\\thinspace .}\nlabel{fem:deq:exer:1D:Poisson:polar:eq}\n\\end{equation}\n\n!et",
  'title': u'Compare finite elements and differences for a radially symmetric Poisson equation',
  'type': u'Exercise',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': 8,
  'chapter_no': 2,
  'chapter_title': u'Variational formulations with finite elements',
  'chapter_type': 'Chapter',
  'closing_remarks': '',
  'file': [u'atan1D_P1'],
  'heading': u'=====',
  'hints': [],
  'keywords': None,
  'label': u'fem:deq:exer:1D:gen:problem2',
  'no': 12,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': u"Consider the problem\n!bt\n\\begin{equation}\n-\\frac{d}{dx}\\left( {\\alpha}(x)\\frac{du}{dx}\\right) + \\gamma u = f(x),\n\\quad x\\in\\Omega=[0,L],\\quad u(0)={\\alpha},\\ u'(L)=\\beta{\\thinspace .}\nlabel{fem:deq:1D:model4}\n\\end{equation}\n\n!et\nWe choose ${\\alpha}(x)=1+x^2$. Then\n!bt\n\\begin{equation} u(x) = {\\alpha} + \\beta(1+L^2)\\tan^{-1}(x),\nlabel{_auto48}\n\\end{equation}\n\n!et\nis an exact solution if $f(x) = \\gamma u$.\n\nDerive a variational formulation and compute general expressions for the\nelement matrix and vector in an arbitrary element, using P1 elements\nand a uniform partitioning of $[0,L]$. The right-hand side\nintegral is challenging and can be computed by a numerical integration\nrule. The Trapezoidal rule (ref{fem:approx:fe:numint1:trapez})\ngives particularly simple expressions.",
  'title': u'Compute with variable coefficients and P1 elements by hand',
  'type': u'Exercise',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': 9,
  'chapter_no': 2,
  'chapter_title': u'Variational formulations with finite elements',
  'chapter_type': 'Chapter',
  'closing_remarks': '',
  'file': [u'torsion_sin_xy'],
  'heading': u'=====',
  'hints': [],
  'keywords': None,
  'label': u'fem:deq:exer:2D:torsion:xy:sin',
  'no': 13,
  'solution': '',
  'solution_file': None,
  'subex': [{'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': u'We consider the basis\n${\\psi}_{p,q}(x,y) = \\sin((p+1)\\pi x)\\sin (q\\pi y)$, $p,q=0,\\ldots,n$.\nThese basis functions fulfill the Dirichlet condition.\nUse a Galerkin method and $n=0$.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': u'The basis function involving sine functions are orthogonal.\nUse this property in the Galerkin method\nto derive the coefficients $c_{p,q}$ in a\nformula $u=\\sum_p\\sum_q c_{p,q}{\\psi}_{p,q}(x,y)$.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': u'Another possible basis is\n${\\psi}_i(x,y) = (x(1-x)y(1-y))^{i+1}$, $i=0,\\ldots,N$.\nUse the Galerkin method to compute the solution for $N=0$.\nWhich choice of a single basis function is best,\n$u\\sim x(1-x)y(1-y)$ or $u\\sim \\sin(\\pi x)\\sin(\\pi y)$?\nIn order to answer the question,\nit is necessary to search the web or the literature for an accurate\nestimate of the maximum $u$ value at $x=y=1/2$.'}],
  'text': u'The classical problem of applying a torque to the ends of a rod\ncan be modeled by a Poisson equation defined in the cross section $\\Omega$:\n\n!bt\n\\[ -\\nabla^2 u = 2,\\quad (x,y)\\in\\Omega,\\]\n\n!et\nwith $u=0$ on $\\partial\\Omega$. Exactly the same problem arises for\nthe deflection of a membrane with shape $\\Omega$ under a constant load.\n\nFor a circular cross section one can readily\nfind an analytical solution. For a rectangular cross section the analytical\napproach ends up with a sine series. The idea in this exercise is to\nuse a single basis function to obtain an approximate answer.\n\nWe assume for simplicity that the cross section is the unit square:\n$\\Omega = [0,1]\\times [0,1]$.',
  'title': u'Solve a 2D Poisson equation using polynomials and sines',
  'type': u'Exercise',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': 10,
  'chapter_no': 2,
  'chapter_title': u'Variational formulations with finite elements',
  'chapter_type': 'Chapter',
  'closing_remarks': '',
  'file': [u'borehole_fenics3D'],
  'heading': u'=====',
  'hints': [u'Use `BoxMesh` as starting point. Consult the FEniCS tutorial cite{ftut1}\nif necessary.'],
  'keywords': None,
  'label': u'fem:fenics:borehole:exer:3D',
  'no': 14,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': u'Solve the problem in Section ref{fem:varform:fenics} in 3D.',
  'title': u'Solve a 3D Laplace problem with FEniCS',
  'type': u'Exercise',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': 11,
  'chapter_no': 2,
  'chapter_title': u'Variational formulations with finite elements',
  'chapter_type': 'Chapter',
  'closing_remarks': '',
  'file': [u'borehole_fenics1D'],
  'heading': u'=====',
  'hints': [u'Use `IntervalMesh` for generating the mesh and introduce a stretching if\ndesired. Consult the FEniCS tutorial cite{ftut1}\nso you can extract the solution in an array\nand make your own curve plot of it.\n\nThis problem can be solved without markers, see the section on\nmultiple Dirichlet conditions in the tutorial cite{ftut1} (it is even\neasier to solve by saying that the solution at the boundary\nobeys a linear function from $u_a$ to $u_b$ and use this as the only\nDirichlet condition).'],
  'keywords': None,
  'label': u'fem:fenics:borehole:exer:1D',
  'no': 15,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': u"Solve the problem in Section ref{fem:varform:fenics} in 1D, using\nthe radial formulation $(ru')'=0$.",
  'title': u'Solve a 1D Laplace problem with FEniCS',
  'type': u'Exercise',
  'type_visible': True}]